## アセンブラ

・NASK：フリーソフトでは有名なアセンブラであるNASMの文法を多く踏襲し筆者が作成したアセンブラ。

### 命令

+ DB命令：data byteの略。[func1]ファイルの内容を1バイトだけ直接書く。[func2]DB 文字列とすることで、文字列のそれぞれに対応する文字コードを並べる。

+ RESB命令：reserve byteの略。指定バイトの領域をあけておく。NASKではあけるだけではなく、そこを0で埋める。

+ DW命令、DD命令：それぞれdata word, data double-wordの略で、DB命令の仲間。wordは16bitをさす。つまり、double-wordは32bit

+ ＄：その行が先頭から何行目かを返す。つまり、DB $を5行目にかけば、ファイルに5と書き込む。

+ ORG命令：originの略。機械語が実行時にPCのメモリのどこに読み込まれることになるかを指定する

+ JMP命令：jumpの略。C言語でいうgo to。

+ ラベル：「entry:」のように文字列:と書く。JMP命令の行き先などに用いる。ラベルが表すのはラベルのある番地である。つまり、MOV AX entryとすれば、entryのある番地がAXに代入される。そして、JMP AXとすれば、AXの表す番地、すなわち、entryのところに飛ぶことができる。

+ MOV命令：moveの略。[func1]基本はMOV AX,0やMOV SS,AXと用いる。日本語に訳すと「移動」だが、実際の操作は代入であり、AX=0, SS=AXとなる。[func2]MOV BYTE [678],123などのように書くとメモリーに代入することができる。BYTEは代入する値の形式をさし、BYTEは1byte、WORDは2byteである。[678]はメモリー上のアドレスをさし、[]で囲って表記する。さきの命令は「メモリー上678番地に1byteのデータ”123”を代入せよ」となる。

+ CMP命令：compareの略。CMP a,bなどのように用い、if(a==b)と相応の処理をする。

+ JE命令：jump if equalの略。CMPの結果a==bの場合には指定されたラベルなどにjumpする。

+ INT命令：interruptの略。ソフトウェア割込み命令で、BIOSの提供する関数を実行する。INT 3などのように書く。INTにつづく数字で度の関数を利用するか選ぶことができる。

+ HLT命令：haltの略。CPUを待機状態にさせる。外部からの入力（マウスを動かす、キーボードに入力する等）で動作を再開する。

+ キャリーフラグ(FLAGS.CF)：1ビットしか記憶できないレジスタをフラグという。CPUはフラグをいくつか持ち、キャリーフラグはキャリー（carry）という状態を示すためのもの。だが、フラグの中ではキャリーフラグが最も使いやすいのでそれ以外の用途でも用いられる。

+ JC命令：jump if carryの略。キャリーフラグが1のときjumpする。

### フロッピーディスクの読み込み

近年のコンピュータではFDDは搭載されていないが当時のPCは多くがFDDドライブを搭載していた。FDDはBIOSだけで読み込みができ、手軽に利用できたようである。

参考：[https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%83%83%E3%83%94%E3%83%BC%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF](https://ja.wikipedia.org/wiki/フロッピーディスク)

## QEMUの使い方

ミニキャンでQEMUが扱ったが、そのときは、UEFIアプリを動かすための設定をいくつかしたと思う。たしかその設定が割と細かく、少しずれるとうまく動かなかったと思う。今回はそれほど細かく設定せずとも動作するようである。
### ドライブの設定

今回の自作OSはフロッピーディスクに入れるので、ドライブの設定をフロッピーディスクとする。それは簡単なオプションがあって、"-fda"で設定できる。
### CPUアーキテクチャの設定
QEMUでエミュレートするCPUのアーキテクチャを設定する。選択肢は割とあって、

    qemu-system-aarch64       qemu-system-mips64        qemu-system-s390x
    qemu-system-alpha         qemu-system-mips64el      qemu-system-sh4
    qemu-system-arm           qemu-system-mipsel        qemu-system-sh4eb
    qemu-system-cris          qemu-system-moxie         qemu-system-sparc
    qemu-system-i386          qemu-system-nios2         qemu-system-sparc64
    qemu-system-lm32          qemu-system-or1k          qemu-system-tricore
    qemu-system-m68k          qemu-system-ppc           qemu-system-unicore32
    qemu-system-microblaze    qemu-system-ppc64         qemu-system-x86_64
    qemu-system-microblazeel  qemu-system-ppc64le       qemu-system-xtensa
    qemu-system-mips          qemu-system-ppcemb        qemu-system-xtensaeb

から選ぶ。今回は"qemu-system-x86_64"を選んだがあってるかは不明（⇐i386がネットでは多い）

## Ubuntuでのディスクイメージの作成

mformat, mcopyコマンドはmtoolsの一部。mtoolsはflopydiskのimgファイルなどの操作のためのツールらしい。

〇mformat
flopy disk imageを作るためのコマンドらしい。おそらく、ファイルシステム上に仮想的なflopy diskを作るイメージでいいいと思う。今回は
~~~
        mformat -f 1440 -C -B ./build/ipl.bin -i helloos.img ::
~~~
とした。
"-f 1440"はフォーマットされたファイルの容量、すなわちflopy disk全体のファイルサイズを指定している。
"-C"これは「ディスクイメージを作成する」という設定(?)
"-B ./build/ipl.bin" "ipl.bin"の内容をboot sectorに書き込むという設定
"-i helloos.img" たぶん"helloos.img"という内容で保存するの意味

〇mcopy
文字どおり、コピーする関数のよう…
~~~
    mcopy ./build/helloos.sys -i helloos.img ::
~~~

参考：
+ https://qiita.com/pollenjp/items/8fcb9573cdf2dc6e2668
+ http://takeisamemo.blogspot.com/2014/09/os30os-3-4.htmlhttp://takeisamemo.blogspot.com/2014/09/os30os-3-4.html
+ https://www.gnu.org/software/mtools/manual/mtools.html

## HRB形式

## C言語の関数とアセンブリ
（参考）https://vanya.jp.net/os/x86call/
　C言語とアセンブリで連携する場合、Cのコンパイラが利用するレジスタと利用しないレジスタが決まっている。利用しないレジスタとして、EAX, ECX, EDXがある。これらは自由に利用することができる。

　引き数はESP+4番地から順に記録されている。つまり、ある関数の一つ目のWORD長の引き数をECXレジスタに代入したい場合には、
~~~nasm
        MOV ECX, [ESP+4]
~~~
とすればよい。
戻り値はEAXに代入すればよい。たとえば、2を戻り値として返す場合は、
~~~nasm
        MOV EAX, 2
~~~
として、
~~~nasm
        RET
~~~
とすればよい。

（補足）
RETの実体は関数の呼び出しもとにJMPする命令である。呼び出し元を管理するのにスタックという考え方が用いられているが、その詳細はここには書かない。参考のURLを参照されたい。

## GDTとIDT
### GDT
　プログラムはパソコンのメモリ上に読み込むことで実行することができる。ローダーを書いた際、ORG命令でメモリのどの番地に読み込まれるかを指定した。しかし、この方法では、複数のプログラムを並列実行する場合などにメモリの番地が競合してしまって、正しく実行できない恐れがある。

　そこで”セグメンテーション”というしくみでそれを解決する。PCの持つメモリ（例えば4GBとすると）をいくつかのメモリのブロックに切り分けて、それぞれのブロックの先頭の番地を0番地として扱う仕組みである。

　つまり、セグメンテーションには以下の情報が必要になる。
+ セグメントの大きさ
+ セグメントの開始番地
+ セグメントの管理用属性

これらを既出のセグメントレジスタを用いて表す。

　上記の情報はたとえば4GBであれば(4GB=4*1024*1024*1024=)2^32個分のアドレス、つまり32bit分のアドレス幅が必要になる。しかし、セグメントレジスタは16bitしかないため、表現ができない。

　そこで、カラーパレットと似たようなしくみを利用する。セグメント番号という概念があり、セグメントレジスタではセグメント番号を記録するようにする。セグメントレジスタは16bit中上位13bitだけがアドレスの指定に使えるため、2^13 = 8192個分の数字が扱える。

　そして、各セグメント番号に対応する数字はメモリ上で記録される。この領域をGDT（Global (segemnt) Descriptor Table）と呼ぶ。GDTの各メモリに32bitの数字を適切に記録していくと、これが上記の三つの情報を表し、CPUはそれを読み取って、正しくメモリを扱えるようになる。

（補足）ページング

詳しく調べていないので理解が間違っていると思うが、とりあえず現時点の認識を、、、

　仮想的なアドレスを用意。そのアドレスに対し適切な変換を用いて物理アドレスと結び付ける。セグメンテーションの考えかたと組み合わせることで、たとえば物理メモリ4GB上で、複数のタスクが4GBのメモリを有するかのようにできる。物理的なアドレスと仮想的なアドレスの対応さえできればよいのだから、4GBのブロックが複数あるかのようにし、各タスクにブロック一つずつを割り当てることができる。もちろん、すべてのタスクの占有するメモリ容量の総和は4GB以下の必要があるが、仮想的なアドレスと物理的なアドレスさえうまくできれば、アドレスはどのように充てることもできる。

　セグメンテーションとあまり違いが感じられないが、ページングは仮想的なアドレスと物理的なアドレスの対応をある程度複雑に設定できるため、細切れのメモリをまるでひと塊の大きなメモリかのように扱える。たとえば、1GB必要なプログラムを動かす場合、セグメンテーションでは1GBの連続するメモリ空間が占有さえれてしまうが、ページングであれば例えば250MBずつの塊が4つありさえすればよい。セグメンテーションに比べ、メモリの利用の自由度が高くなると分かる。

#### 構造体 SEGMENT_DESCRIPTOR
　上記の3つの情報と付加的な情報を64bitの数字で表す必要がある。セグメントの開始番地でさえ32bitあるから、非常に難儀なように思われるが、IBMの仕様に従えば問題はない。

SEGMENT_DESCRIPTOR構造体は64bit(8byte)を以下のように分けている。

+ [64bit\~56bit]   baseの上位8bit
+ [56bit\~52bit]   ar(access right)の上位4bit
+ [52bit\~48bit]   limitの上位4bit
+ [48bit\~40bit]   ar(access right)の下位8bit
+ [40bit\~32bit]   baseの中位8bit
+ [32bit\~16bit]   baseの下位16bit
+ [16bit\~ 0bit]   limitの下位16bit
  
のようである。

　さて、limitは20bitの長さであることが分かるが、20bitでは32bit分の長さを表しきることができない。そのため、limitの上位4bitのうちの最上位ビットで、”単位”を設定するようにしている。arの上位4bitのうちの最上位ビットはGビットとよばれ（Granularity 粒度の頭文字）、Gビットが1の場合、limitはページ(4KBのこと)単位になる。0にすればバイト単位である。つまり、limitには20bitしか割り当てられていないが、8GB(4KB単位)もしくは2MB(1byte単位)まで指定できる。

　arの上位4bitの最上位ビットはGビットであった。他のビットもさまざまな設定をしている。詳しくは、本書を参照したりほかに勉強する必要がある。　

### IDT
　CPUにはマウスやキーボード、ネットワークカードやHDD、ディスプレイやスピーカーといった多種多様な機器が接続されている。それらをすべてコントロールしようと、各クロックのたびにCPUが処理していては処理が重くなってしまう。そこで割込みという仕組みが用いられている。

　マイコンなどの割込み同様、入力の状態に変化があれば、現在の動作を一時中断し割込み処理に入る機能である。CPUもそれらの機器の変化から割込みが発生し、進行中の処理を一時中断し、それらの処理に入る機能が備えられている。

　CPUの割込みはIDT(Interrupt Descriptor Table)というしくみで制御されている。IDTでは割込み番号が0~255まであり、各割込み番号に対して、割り込んだ場合に実行する関数を設定する。

## PIC
　PICはprogrammable interrupt controllerの略で、CPUの割込みを管理する。CPUは割込みようのピンを一本しか有していないが、PICにより15個の割込みを扱うことができるようになる。というのも、PICには全体で15本の入力と一本の出力を有しており、15本のうちに一つでも割込みがあれば、出力で割込みを生じる。
　PICの構成はより具体的にマスタPICとスレーブPICからなっている。マスタPIC、スレーブPICはともに一本の出力、8本の入力ポートを有しており、スレーブの出力はマスタの2番入力につながっている。これにより、15本の入力を扱える。
　PICの入力ポートはIRQ0~IRQ15まで名前がついている(16個の入力が扱えそうだが、IRQ2はスレーブPICとマスタPICのやり取りに使われるから、やはり15個までである）。

### IMR
　IMRとはinterrupt mask registerの略で、割込み目隠しレジスタと呼ばれる。IMRは8bitのレジスタで各ビットが各IRQに対応している。あるビットを1にすれば、そのビットに対応するIRQは「目隠し」されて、そのIQRの割込みはCPUで無視されるようになる。IMRの目的としては、設定中に割込みが起こるとまずい場合などに割込みを起きないようにしておくためであったり、何にも接続されていないIRQが静電気などで反応しOSの動作を不安定にさせることを防いだりする為であったりする。たぶんだけど、IRQは16本あるから、IMRも二つあるはず。

### ICW
　ICWとはinitial control wordの略。ICWは8bitのレジスタだが、ICW1~ICW4まであるので計4byteになる。日本語だと「初期化制御データ」。例えばICW1とICW4ではCPUに対しPICが基板でどのように接続されているかといった情報を提供する。

ICWは（たぶん）マスタ、スレーブそれぞれに設定するが、ICW3はマスタに対してはどこのIRQがスレーブにつながっているかを8bitで、スレーブに対してはスレーブがマスタの何番につながっているかを3bitで指定する。これはハードウェアで決まった値をとるので、規定値を設定する。

OSを自作するうえではICW2に注意を払う必要がある。ICW2ではどのIRQがCPUのどの割込み番号に対応するかを決めることができる。CPUは割込みを受け付けると、PICに対し2バイトのデータを要求する。2バイトのデータの中身は「0xcd 0x??」になっている。これはアセンブリでいう、
~~~nasm
    INT 0x??
~~~
に対応する。つまり、PICの送り返す信号によりCPUはIRQのどれに対応する割込みかを知ることができる。

## 割込みハンドラ作成
　まず割込みが起こった場合の処理はアセンブリで書く必要がある。アセンブリ側で割込みを受け付け、Cの関数を呼び出す。そうすることで、C言語による割込み処理を行えるようになり、複雑な処理も扱えるようになる。
　C言語側の割込み処理はday6の段階では文字を表示するだけである。重要なのは、アセンブリ側の関数である。
~~~nasm
_asm_inthandler21:
		PUSH	ES
		PUSH	DS
		PUSHAD
		MOV		EAX,ESP
		PUSH	EAX
		MOV		AX,SS
		MOV		DS,AX
		MOV		ES,AX
		CALL	_inthandler21
		POP		EAX
		POPAD
		POP		DS
		POP		ES
		IRETD
~~~

PUSH、POPはスタックの操作に関わる命令である。とはいうものの、PUSHの実体は

~~~nasm
    ADD ESP, -4
    MOV [SS:ESP], EAX
~~~

という命令である。つまり、スタックの先頭アドレスを表しているEAXレジスタの値を4byte分へらし、EAXレジスタの指す該当番地にEAXレジスタの内容を代入するといったものである。POP命令の方も

~~~nasm
    MOV EAX, [SS:ESP]
    ADD ESP, 4
~~~

という命令になっており対応している。

　割込み処理では今までの処理を一時中断し別の処理を行う。割込みが終わった後は、再びいままでの処理に戻る為、CPUをもとの状態に戻す必要がある。そこで、割込みの間、レジスタの値をバックアップしておく必要がある。PUSHAD命令はまさにその命令で、
~~~nasm
PUSH    EAX
PUSH    ECX
PUSH    EDX
PUSH    EBX
PUSH    ESP
PUSH    EBP
PUSH    ESI
PUSH    EDI
~~~
という命令の集合になっている。これによりレジスタの値をバックアップできる。

　ESとDSの値もバックアップしている。これはCの関数を呼び出す関係で必要な処理だが、CではSSとDSとESが等しくなっている必要がある。そのため、ESとDSはバックアップしたうえでSSと値をそろえ、Cの関数を呼ぶようにしている。

　CALLはCの関数を呼ぶ命令である。関数名はアセンブリ冒頭のEXTERNで宣言してある。CALLたあとCの関数から帰ってくると、バックアップしたレジスタの値をもとに戻し、IRETD命令で割込み処理を終えている。割込みではRETではなくIRTEDを使う必要があるようである。