## アセンブラ

・NASK：フリーソフトでは有名なアセンブラであるNASMの文法を多く踏襲し筆者が作成したアセンブラ。

###　命令

・DB命令：data byteの略。[func1]ファイルの内容を1バイトだけ直接書く。[func2]DB 文字列とすることで、文字列のそれぞれに対応する文字コードを並べる。

・RESB命令：reserve byteの略。指定バイトの領域をあけておく。NASKではあけるだけではなく、そこを0で埋める。

・DW命令、DD命令：それぞれdata word, data double-wordの略で、DB命令の仲間。wordは16bitをさす。つまり、double-wordは32bit

・＄：その行が先頭から何行目かを返す。つまり、DB $を5行目にかけば、ファイルに5と書き込む。

・ORG命令：originの略。機械語が実行時にPCのメモリのどこに読み込まれることになるかを指定する

・JMP命令：jumpの略。C言語でいうgo to。

・ラベル：「entry:」のように文字列:と書く。JMP命令の行き先などに用いる。ラベルが表すのはラベルのある番地である。つまり、MOV AX entryとすれば、entryのある番地がAXに代入される。そして、JMP AXとすれば、AXの表す番地、すなわち、entryのところに飛ぶことができる。

・MOV命令：moveの略。[func1]基本はMOV AX,0やMOV SS,AXと用いる。日本語に訳すと「移動」だが、実際の操作は代入であり、AX=0, SS=AXとなる。[func2]MOV BYTE [678],123などのように書くとメモリーに代入することができる。BYTEは代入する値の形式をさし、BYTEは1byte、WORDは2byteである。[678]はメモリー上のアドレスをさし、[]で囲って表記する。さきの命令は「メモリー上678番地に1byteのデータ”123”を代入せよ」となる。

・CMP命令：compareの略。CMP a,bなどのように用い、if(a==b)と相応の処理をする。

・JE命令：jump if equalの略。CMPの結果a==bの場合には指定されたラベルなどにjumpする。

・INT命令：interruptの略。ソフトウェア割込み命令で、BIOSの提供する関数を実行する。INT 3などのように書く。INTにつづく数字で度の関数を利用するか選ぶことができる。

・HLT命令：haltの略。CPUを待機状態にさせる。外部からの入力（マウスを動かす、キーボードに入力する等）で動作を再開する。

・キャリーフラグ(FLAGS.CF)：1ビットしか記憶できないレジスタをフラグという。CPUはフラグをいくつか持ち、キャリーフラグはキャリー（carry）という状態を示すためのもの。だが、フラグの中ではキャリーフラグが最も使いやすいのでそれ以外の用途でも用いられる。

・JC命令：jump if carryの略。キャリーフラグが1のときjumpする。

### フロッピーディスクの読み込み

近年のコンピュータではFDDは搭載されていないが当時のPCは多くがFDDドライブを搭載していた。FDDはBIOSだけで読み込みができ、手軽に利用できたようである。

参考：[https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%83%83%E3%83%94%E3%83%BC%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF](https://ja.wikipedia.org/wiki/フロッピーディスク)

### QEMUの使い方
    　ミニキャンでQEMUが扱ったが、そのときは、UEFIアプリを動かすための設定をいくつかしたと思う。
    たしかその設定が割と細かく、少しずれるとうまく動かなかったと思う。
    今回はそれほど細かく設定せずとも動作するようである。
#### ドライブの設定
    　今回の自作OSはフロッピーディスクに入れるので、ドライブの設定をフロッピーディスクとする。それは簡単なオプションがあって、"-fda"で設定できる。
#### CPUアーキテクチャの設定
    　QEMUでエミュレートするCPUのアーキテクチャを設定する。選択肢は割とあって、
    qemu-system-aarch64       qemu-system-mips64        qemu-system-s390x
    qemu-system-alpha         qemu-system-mips64el      qemu-system-sh4
    qemu-system-arm           qemu-system-mipsel        qemu-system-sh4eb
    qemu-system-cris          qemu-system-moxie         qemu-system-sparc
    qemu-system-i386          qemu-system-nios2         qemu-system-sparc64
    qemu-system-lm32          qemu-system-or1k          qemu-system-tricore
    qemu-system-m68k          qemu-system-ppc           qemu-system-unicore32
    qemu-system-microblaze    qemu-system-ppc64         qemu-system-x86_64
    qemu-system-microblazeel  qemu-system-ppc64le       qemu-system-xtensa
    qemu-system-mips          qemu-system-ppcemb        qemu-system-xtensaeb
    から選ぶ。今回は"qemu-system-x86_64"を選んだがあってるかは不明
    （⇐i386がネットでは多い）

### Ubuntuでのディスクイメージの作成
    　mformat, mcopyコマンドはmtoolsの一部。mtoolsはflopydiskのimgファイルなどの
    操作のためのツールらしい。
    〇mformat
    flopy disk imageを作るためのコマンドらしい。おそらく、ファイルシステム上に仮想的なflopy diskを作るイメージでいいいと思う。今回は
        mformat -f 1440 -C -B ./build/ipl.bin -i helloos.img ::
    とした。
    "-f 1440"はフォーマットされたファイルの容量、すなわちflopy disk全体のファイルサイズを指定している。
    "-C"これは「ディスクイメージを作成する」という設定(?)
    "-B ./build/ipl.bin" "ipl.bin"の内容をboot sectorに書き込むという設定
    "-i helloos.img" たぶん"helloos.img"という内容で保存するの意味
    
    〇mcopy
    文字どおり、コピーする関数のよう…
	mcopy ./build/helloos.sys -i helloos.img ::
    
    参考：https://qiita.com/pollenjp/items/8fcb9573cdf2dc6e2668
    参考：http://takeisamemo.blogspot.com/2014/09/os30os-3-4.htmlhttp://takeisamemo.blogspot.com/2014/09/os30os-3-4.html
    参考：https://www.gnu.org/software/mtools/manual/mtools.html

### HRB形式

### C言語の関数とアセンブリ
    （参考）https://vanya.jp.net/os/x86call/
    　C言語とアセンブリで連携する場合、Cのコンパイラが利用するレジスタと利用しないレジスタが決まっている。利用しないレジスタとして、EAX, ECX, EDXがある。これらは自由に利用することができる。
    　引き数はESP+4番地から順に記録されている。つまり、ある関数の一つ目のWORD長の引き数をECXレジスタに代入したい場合には、
        MOV ECX, [ESP+4]
    とすればよい。
    　戻り値はEAXに代入すればよい。たとえば、2を戻り値として返す場合は、
        MOV EAX, 2
    として、
        RET
    とすればよい。
    
    （補足）
    RETの実体は関数の呼び出しもとにJMPする命令である。呼び出し元を管理するのにスタックという考え方が用いられているが、その詳細はここには書かない。参考のURLを参照されたい。

### GDT
    　プログラムはパソコンのメモリ上に読み込むことで実行することができる。ローダーを書いた際、ORG命令でメモリのどの番地に読み込まれるかを指定した。しかし、この方法では、複数のプログラムを並列実行する場合などにメモリの番地が競合してしまって、正しく実行できない恐れがある。
    　そこで”セグメンテーション”というしくみでそれを解決する。PCの持つメモリ（例えば4GBとすると）をいくつかのメモリのブロックに切り分けて、それぞれのブロックの先頭の番地を0番地として扱う仕組みである。
    　つまり、セグメンテーションには以下の情報が必要になる。
        ・セグメントの大きさ
        ・セグメントの開始番地
        ・セグメントの管理用属性
    これらを既出のセグメントレジスタを用いて表す。
    　上記の情報はたとえば4GBであれば(4GB=4*1024*1024*1024=)2^32個分のアドレス、つまり32bit分のアドレス幅が必要になる。しかし、セグメントレジスタは16bitしかないため、表現ができない。
    　そこで、カラーパレットと似たようなしくみを利用する。セグメント番号という概念があり、セグメントレジスタではセグメント番号を記録するようにする。セグメントレジスタは16bit中上位13bitだけがアドレスの指定に使えるため、2^13 = 8192個分の数字が扱える。
    　そして、各セグメント番号に対応する数字はメモリ上で記録される。この領域をGDT（Global (segemnt) Descriptor Table）と呼ぶ。GDTの各メモリに32bitの数字を適切に記録していくと、これが上記の三つの情報を表し、CPUはそれを読み取って、正しくメモリを扱えるようになる。
    　
    （補足）ページング
    詳しく調べていないので理解が間違っていると思うが、とりあえず現時点の認識を、、、
    　仮想的なアドレスを用意。そのアドレスに対し適切な変換を用いて物理アドレスと結び付ける。セグメンテーションの考えかたと組み合わせることで、たとえば物理メモリ4GB上で、複数のタスクが4GBのメモリを有するかのようにできる。物理的なアドレスと仮想的なアドレスの対応さえできればよいのだから、4GBのブロックが複数あるかのようにし、各タスクにブロック一つずつを割り当てることができる。もちろん、すべてのタスクの占有するメモリ容量の総和は4GB以下の必要があるが、仮想的なアドレスと物理的なアドレスさえうまくできれば、アドレスはどのように充てることもできる。
    　セグメンテーションとあまり違いが感じられないが、ページングは仮想的なアドレスと物理的なアドレスの対応をある程度複雑に設定できるため、細切れのメモリをまるでひと塊の大きなメモリかのように扱える。たとえば、1GB必要なプログラムを動かす場合、セグメンテーションでは1GBの連続するメモリ空間が占有さえれてしまうが、ページングであれば例えば250MBずつの塊が4つありさえすればよい。セグメンテーションに比べ、メモリの利用の自由度が高くなると分かる。

#### 構造体 SEGMENT_DESCRIPTOR
    　上記の3つの情報と付加的な情報を64bitの数字で表す必要がある。セグメントの開始番地でさえ32bitあるから、非常に難儀なように思われるが、IBMの仕様に従えば問題はない。
    　SEGMENT_DESCRIPTOR構造体は64bit(8byte)を以下のように分けている。
        [64bit~56bit]   baseの上位8bit
        [56bit~52bit]   ar(access right)の上位4bit
        [52bit~48bit]   limitの上位4bit
        [48bit~40bit]   ar(access right)の下位8bit
        [40bit~32bit]   baseの中位8bit
        [32bit~16bit]   baseの下位16bit
        [16bit~ 0bit]   limitの下位16bit
    のようである。
    　さて、limitは20bitの長さであることが分かるが、20bitでは32bit分の長さを表しきることができない。そのため、limitの上位4bitのうちの最上位ビットで、”単位”を設定するようにしている。arの上位4bitのうちの最上位ビットはGビットとよばれ（Granularity 粒度の頭文字）、Gビットが1の場合、limitはページ(4KBのこと)単位になる。0にすればバイト単位である。つまり、limitには20bitしか割り当てられていないが、8GB(4KB単位)もしくは2MB(1byte単位)まで指定できる。
    　arの上位4bitの最上位ビットはGビットであった。他のビットもさまざまな設定をしている。詳しくは、本書を参照したりほかに勉強する必要がある。　

### IDT
    　CPUにはマウスやキーボード、ネットワークカードやHDD、ディスプレイやスピーカーといった多種多様な機器が接続されている。それらをすべてコントロールしようと、各クロックのたびにCPUが処理していては処理が重くなってしまう。そこで割込みという仕組みが用いられている。
    　マイコンなどの割込み同様、入力の状態に変化があれば、現在の動作を一時中断し割込み処理に入る機能である。CPUもそれらの機器の変化から割込みが発生し、進行中の処理を一時中断し、それらの処理に入る機能が備えられている。
    　CPUの割込みはIDT(Interrupt Descriptor Table)というしくみで制御されている。IDTでは割込み番号が0~255まであり、各割込み番号に対して、割り込んだ場合に実行する関数を設定する。

### PIC
    